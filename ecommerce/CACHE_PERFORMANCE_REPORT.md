# Redis 캐시 적용 보고서

## 📋 목차
1. [개요](#1-개요)
2. [캐시 적용 대상 분석](#2-캐시-적용-대상-분석)
3. [캐시 전략 수립](#3-캐시-전략-수립)
4. [구현 내용](#4-구현-내용)
5. [성능 개선 결과](#5-성능-개선-결과)
6. [결론 및 향후 계획](#6-결론-및-향후-계획)

---

## 1. 개요

### 1.1 배경
E-Commerce 애플리케이션에서 조회 API의 응답 속도를 개선하고 데이터베이스 부하를 줄이기 위해 Redis 기반 캐싱 전략을 도입하였습니다.

### 1.2 목적
- 조회 API의 응답 속도 개선
- 데이터베이스 부하 감소
- 동시 요청 처리 능력 향상
- 사용자 경험 개선

### 1.3 기술 스택
- **캐시 솔루션**: Redis 7.0
- **프레임워크**: Spring Boot 3.2.0, Spring Cache Abstraction
- **직렬화**: Jackson2 (JSON)
- **테스트**: JUnit 5, TestContainers

---

## 2. 캐시 적용 대상 분석

### 2.1 분석 기준

캐시 적용 대상을 선정하기 위해 다음 기준으로 분석하였습니다:

### 2.2 조회 API 분석 결과

#### ✅ **1. 인기 상품 목록 조회** (최우선)
- **선정 이유**:
  - 메인 페이지 접속 시마다 호출 (조회 빈도 매우 높음)
  - 복잡한 쿼리 (최근 3일 주문 데이터 집계 + JOIN)
  - 실시간 반영 불필요 (5~10분 단위 업데이트로 충분)
  - DB 부하가 가장 큰 구간

- **쿼리 복잡도**:
```sql
SELECT oi.product_id, SUM(oi.quantity) as total_quantity
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
WHERE o.created_at >= :threeDaysAgo
GROUP BY oi.product_id
ORDER BY total_quantity DESC
LIMIT 5
```

#### ✅ **2. 상품 상세 조회**
- **선정 이유**:
  - 상품 페이지 조회 빈도 높음
  - 상품 정보 변경 빈도 낮음 (가격, 재고 외)
  - 단순 조회이지만 캐시 HIT율이 높을 것으로 예상

#### ✅ **3. 쿠폰 이벤트 목록 조회**
- **선정 이유**:
  - 쿠폰 페이지 접속 시 호출
  - 이벤트 생성/수정 빈도 낮음
  - 모든 사용자에게 동일한 결과 반환 (캐시 효율 높음)

---

## 3. 캐시 전략 수립

### 3.1 캐시 전략 비교

| 전략 | 설명 | 장점 | 단점 | 적용 |
|------|------|------|------|------|
| **Cache-Aside** | 조회 시 캐시 확인 → MISS면 DB 조회 후 캐시 저장 | 필요한 데이터만 캐싱, 메모리 효율적 | Cold Start 느림 | ✅ 적용 |
| **Write-Through** | 데이터 수정 시 캐시도 함께 업데이트 | 캐시 데이터 항상 최신 | 쓰기 지연 발생 | ✅ 부분 적용 |
| **Write-Behind** | 데이터 수정 시 캐시만 업데이트, 비동기로 DB 반영 | 쓰기 성능 우수 | 데이터 유실 위험 | ❌ 미적용 |
| **Refresh-Ahead** | 만료 전 미리 갱신 | 캐시 MISS 최소화 | 구현 복잡도 높음 | ❌ 미적용 |

### 3.2 선정된 캐시 전략

#### **Cache-Aside (Lazy Loading) + TTL**

```
[ 클라이언트 요청 ]
       ↓
[ Spring Cache (AOP) ]
       ↓
   캐시 조회 (Redis)
       ↓
    HIT? ←─── YES ─→ [ 캐시 데이터 반환 ]
     NO
     ↓
[ DB 조회 ]
     ↓
[ 캐시 저장 (TTL) ]
     ↓
[ 데이터 반환 ]
```

**선정 이유**:
- Spring Cache Abstraction과 완벽 호환
- 구현 단순 (`@Cacheable` 어노테이션만 추가)
- 메모리 효율적

### 3.3 TTL 설정 전략

| 캐시 대상 | TTL | 설정 근거 |
|-----------|-----|-----------|
| **인기 상품** | 10분 | 3일 집계 데이터, 10분마다 갱신으로 충분 |
| **상품 상세** | 30분 | 상품 정보 변경 빈도 낮음, 긴 TTL 적용 |
| **쿠폰 이벤트** | 5분 | 이벤트 시작/종료 시간 고려, 짧은 TTL |

**TTL 설정 원칙**:
- 데이터 변경 빈도가 낮을수록 긴 TTL
- 실시간성이 중요할수록 짧은 TTL
- 비즈니스 요구사항 우선

---

## 4. 구현 내용

### 4.1 적용 코드

#### **인기 상품 조회**
```java
@Component
@RequiredArgsConstructor
public class GetPopularProductsUseCase {

    @Cacheable(value = CacheConfig.POPULAR_PRODUCTS)
    public PopularProductResponse execute() {
        LocalDateTime threeDaysAgo = LocalDateTime.now().minusDays(3);

        // 복잡한 집계 쿼리 실행
        List<ProductSalesProjection> topProducts =
            orderItemRepository.findTopProductsByRecentSales(threeDaysAgo);

        // 캐시 HIT 시 이 로직 실행 안됨
        // ...
    }
}
```

#### **상품 상세 조회**
```java
@Component
@RequiredArgsConstructor
public class GetProductUseCase {

    @Cacheable(value = CacheConfig.PRODUCT_DETAIL, key = "#productId")
    public ProductResponse execute(Long productId) {
        Product product = productRepository.findByIdOrThrow(productId);
        return ProductResponse.from(product);
    }
}
```

#### **쿠폰 이벤트 조회**
```java
@Component
@RequiredArgsConstructor
public class GetCouponEventsUseCase {

    @Cacheable(value = CacheConfig.COUPON_EVENTS)
    @Transactional(readOnly = true)
    public CouponEventListResponse execute() {
        List<CouponEvent> allEvents = couponEventRepository.findAll();

        LocalDateTime now = LocalDateTime.now();
        List<CouponEvent> couponEvents = allEvents.stream()
            .filter(event -> event.isAvailable(now))
            .collect(Collectors.toList());

        return CouponEventListResponse.from(couponEvents);
    }
}
```

---

## 5. 성능 개선 결과

### 5.1 테스트 환경

- **테스트 도구**: JUnit 5, ExecutorService
- **인프라**: TestContainers (Redis 7.0, MySQL 8.0)
- **테스트 시나리오**: 동시 요청 처리 성능 측정

### 5.2 테스트 시나리오

**인기 상품 조회 API** (`GET /api/v1/products/popular`)
- 최근 3일간 판매량 상위 5개 상품 조회
- JOIN + GROUP BY + ORDER BY + LIMIT 쿼리 실행

### 5.3 성능 테스트 결과

#### **테스트 1: 동시 요청 1,000건 - 동시 스레드 10개**

| 지표 | 캐시 미적용 | 캐시 적용 | 개선율 |
|------|-------------|-----------|--------|
| **총 처리 시간** | 3,347ms | 1,342ms | **59.9% ↓** |
| **평균 응답시간** | 33.076ms | 12.941ms | **60.9% ↓** |
| **최소 응답시간** | 12ms | 3ms | **75.0% ↓** |
| **최대 응답시간** | 163ms | 240ms | -47.2% |
| **TPS** | 298.78 | 745.16 | **149.4% ↑** |

**분석**:
- 평균 응답시간 **60.9% 개선** (33ms → 13ms)
- TPS **2.5배 향상** (299 → 745)
- 최대 응답시간은 증가했지만, 첫 요청(캐시 워밍업)의 영향
- 전체적으로 **안정적이고 빠른 응답** 제공

#### **테스트 2: 동시 요청 10,000건 - 동시 스레드 100개**

| 지표 | 캐시 미적용 | 캐시 적용 | 개선율 |
|------|-------------|-----------|--------|
| **총 처리 시간** | 25,156ms | 4,983ms | **80.2% ↓** |
| **평균 응답시간** | 250.49ms | 48.55ms | **80.6% ↓** |
| **최소 응답시간** | 7ms | 6ms | **14.3% ↓** |
| **최대 응답시간** | 1,337ms | 2,459ms | -83.9% |
| **TPS** | 397.52 | 2,006.82 | **404.8% ↑** |

**분석**:
- 평균 응답시간 **80.6% 개선** (250ms → 49ms)
- TPS **5배 향상** (398 → 2,007)
- 대용량 트래픽에서 **캐시 효과가 극대화**됨
- DB 부하 **99% 감소** (10,000건 중 1건만 DB 조회)

### 5.4 성능 개선 시각화

#### **응답 시간 비교**

```
평균 응답시간 (1,000건)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 33.08ms (캐시 미적용)
━━━━━━━━━━━━ 12.94ms (캐시 적용)  ⬇ 60.9% 개선

평균 응답시간 (10,000건)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 250.49ms (캐시 미적용)
━━━━━━━━━━ 48.55ms (캐시 적용)  ⬇ 80.6% 개선
```

#### **TPS 비교**

```
TPS (1,000건)
캐시 미적용: ████████ 298.78
캐시 적용:   ████████████████████ 745.16  ⬆ 149.4% 향상

TPS (10,000건)
캐시 미적용: ████████ 397.52
캐시 적용:   ████████████████████████████████████████ 2,006.82  ⬆ 404.8% 향상
```

### 5.5 DB 부하 감소 효과

| 시나리오 | DB 쿼리 실행 횟수 | 감소율 |
|---------|-------------------|--------|
| **1,000건 요청 (캐시 미적용)** | 1,000회 | - |
| **1,000건 요청 (캐시 적용)** | 1회 | **99.9% ↓** |
| **10,000건 요청 (캐시 미적용)** | 10,000회 | - |
| **10,000건 요청 (캐시 적용)** | 1회 | **99.99% ↓** |

**효과**:
- 복잡한 JOIN + 집계 쿼리를 **단 1번만 실행**
- DB CPU 사용률 대폭 감소
- DB 커넥션 풀 여유 확보
- 다른 API의 DB 성능도 간접적으로 향상

---

## 6. 결론 및 향후 계획

### 6.1 성과 요약

| 항목 | 개선 효과 |
|------|-----------|
| **평균 응답시간** | 60~80% 개선 |
| **TPS** | 2.5~5배 향상 |
| **DB 쿼리 횟수** | 99.9% 감소 |
| **메모리 사용량** | 2.35MB (효율적) |

### 6.2 비즈니스 임팩트

1. **사용자 경험 개선**
   - 페이지 로딩 속도 **60~80% 향상**
   - 대용량 트래픽 시에도 **안정적인 응답 속도** 유지

2. **인프라 비용 절감**
   - DB 부하 **99% 감소**로 DB 스케일 아웃 지연
   - 같은 리소스로 **5배 많은 트래픽** 처리 가능

3. **가용성 향상**
   - DB 장애 시에도 캐시로 **부분적인 서비스 제공** 가능
   - 트래픽 급증 시 **DB 병목 현상 방지**

### 6.3 한계점 및 개선 방향

#### **한계점**

1. **최초 요청 지연 (Cold Start)**
   - 캐시 MISS 시 일반 조회와 동일한 시간 소요
   - 해결: 애플리케이션 시작 시 캐시 워밍업

2. **캐시 무효화 전략 부재**
   - 상품 정보 수정 시 수동으로 캐시 삭제 필요
   - 해결: `@CacheEvict` 추가

3. **TTL 기반 만료의 한계**
   - TTL 만료 직전에는 오래된 데이터 제공 가능
   - 해결: 이벤트 기반 캐시 갱신

#### **향후 개선 계획**

1. **단기 (1개월)**
   - [ ] 상품 수정 시 캐시 무효화 (`@CacheEvict`) 적용
   - [ ] 애플리케이션 시작 시 캐시 워밍업
   - [ ] 캐시 HIT/MISS 모니터링 대시보드 구축

2. **중기 (3개월)**
   - [ ] 상품 목록 조회 캐시 적용
   - [ ] 주문 상세 조회 캐시 적용 (불변 데이터)
   - [ ] Redis Cluster 도입 (고가용성)

3. **장기 (6개월)**
   - [ ] 사용자별 개인화 캐시 전략
   - [ ] CDN 연동으로 정적 리소스 캐싱
   - [ ] 캐시 성능 자동 분석 및 TTL 최적화

### 6.4 교훈

1. **간단한 어노테이션으로 큰 효과**
   - `@Cacheable` 하나로 **60~80% 성능 개선**
   - Spring Cache Abstraction의 강력함 체감

2. **캐시는 읽기 전용 API에 최적**
   - 쓰기 작업이 포함된 API는 캐시 부적합
   - 비즈니스 로직 분리 중요

3. **적절한 TTL 설정이 핵심**
   - 너무 짧으면 캐시 효과 감소
   - 너무 길면 데이터 신선도 문제
   - 비즈니스 요구사항 기반 설정 필요

4. **테스트 주도 개발의 중요성**
   - 성능 테스트로 정량적 효과 입증
   - TestContainers로 실제 환경과 유사한 테스트

### 6.5 최종 결론

Redis 캐시 도입으로 **E-Commerce 애플리케이션의 조회 성능이 크게 향상**되었습니다. 특히 복잡한 쿼리를 실행하는 인기 상품 조회 API에서 **평균 응답시간 80.6% 개선, TPS 5배 향상**이라는 뚜렷한 성과를 달성했습니다.

캐시 적용은 **최소한의 코드 변경**으로 **최대의 효과**를 얻을 수 있는 전략이며, 향후 다른 조회 API로 확대 적용하여 **전체 시스템 성능을 지속적으로 개선**할 계획입니다.