# 선착순 쿠폰 발급 시스템 - 비동기 처리 설계 및 개발 회고

---

## 1. 프로젝트 개요

### 1.1 배경
E-Commerce 서비스에서 선착순 쿠폰 이벤트는 순간적으로 수만 명의 동시 접속이 발생하는 대표적인 트래픽 집중 상황입니다. 기존의 DB 기반 동기 처리 방식으로는 다음과 같은 문제가 발생했습니다:

- 분산 락으로 인한 성능 저하 (응답 시간 1초 이상)
- DB 커넥션 풀 고갈
- 트랜잭션 타임아웃 증가
- 사용자 경험 저하

### 1.2 목표
**Redis 기반 비동기 처리 시스템**을 구축하여:
- 빠른 응답 시간 보장 (200ms 이내)
- 정확한 선착순 처리 (재고 관리)
- 중복 발급 방지 (100% 정확도)

---

## 2. 문제 정의 및 요구사항

### 2.1 비즈니스 요구사항

**시나리오:**
```
- 쿠폰 수량: 5,000개
- 예상 동시 접속: 10,000명
- 이벤트 시작: 오전 10시 정각
```

**필수 요구사항:**
1. ✅ 정확히 5,000명만 발급 성공 (초과 발급 금지)
2. ✅ 중복 발급 절대 불가
3. ✅ 빠른 응답 (사용자는 몇 초 이상 기다리지 않음)
4. ✅ 선착순 보장 (먼저 요청한 사람이 우선)
5. ✅ 발급 실패 시 명확한 이유 전달 (재고 부족 vs 중복)
6. 
---

## 3. 시스템 아키텍처 설계

### 3.1 전체 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                        Client Layer                          │
│                  (10,000 concurrent users)                   │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                    Spring Boot API Server                    │
│                   (IssueCouponUseCase)                       │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
        ┌────────────────┴────────────────┐
        │                                  │
        ▼                                  ▼
┌──────────────────┐            ┌──────────────────┐
│  Redis (Cache)   │            │  MySQL (RDB)     │
│                  │            │                  │
│ - ZSET: 중복체크  │            │ - UserCoupon     │
│ - List: 큐       │◄───────────│ - CouponEvent    │
│ - String: 재고   │  Batch     │                  │
└──────────────────┘  Scheduler └──────────────────┘
                         ▲
                         │ (10초마다)
                         │
                ┌────────┴─────────┐
                │ CouponBatch      │
                │ Scheduler        │
                │ (비동기 처리)     │
                └──────────────────┘
```

### 3.2 Redis 자료구조 설계

#### 3.2.1 설계 원칙
- **단일 책임**: 각 자료구조는 하나의 역할만 담당
- **원자성**: 가능한 Redis의 원자적 연산 활용
- **메모리 효율**: 불필요한 데이터는 즉시 삭제

#### 3.2.2 자료구조 상세

**1. ZSET (발급 기록 + 중복 체크)**
```
키: coupon:issued:{eventId}
구조: ZSET {userId: timestamp}

예시:
coupon:issued:1
  - "100": 1733497200001.0
  - "101": 1733497200002.0
  - "102": 1733497200003.0

역할:
- ZADD NX로 중복 발급 원자적 방지
- Score(timestamp)로 발급 순서 추적
- ZCARD로 발급자 수 O(1) 조회
- 영구 기록 (TTL 30일)
```

**2. List Queue (배치 처리 대기열)**
```
키: coupon:queue:{eventId}
구조: List [userId1, userId2, ...]

예시:
coupon:queue:1 = ["100", "101", "102", ...]

역할:
- RPUSH로 발급 요청 순차 추가
- LPOP으로 배치 처리 시 꺼내기
- 임시 데이터 (처리 후 자동 삭제)
```

**3. String (재고 관리)**
```
키: coupon:stock:{eventId}
구조: String (숫자)

예시:
coupon:stock:1 = "4997"

역할:
- DECR로 원자적 재고 차감
- INCR로 롤백 시 복구
```

#### 3.2.3 왜 3개 자료구조를 사용하는가?

| 자료구조 | 역할 | 대안 | 선택 이유 |
|---------|------|------|----------|
| **ZSET** | 중복 체크 + 기록 | SETNX (String) | 타임스탬프 저장, ZCARD로 카운트, 메모리 효율 |
| **List** | 배치 큐 | ZSET으로 통합 | 역할 분리, 처리 후 삭제로 메모리 절약 |
| **String** | 재고 관리 | ZCARD 사용 | DECR 원자적 연산, 독립적 재고 관리 |

### 3.3 처리 흐름

#### 3.3.1 동기 처리 단계 (즉시 응답)

```
[Client Request]
    │
    ▼
┌─────────────────────────────────────────┐
│  1. ZADD NX (중복 체크)                  │
│     coupon:issued:{eventId}              │
│     → 이미 존재? 중복 발급 실패          │
│     → 새로운 userId? 계속 진행           │
└─────────────┬───────────────────────────┘
              │ ✅ Success
              ▼
┌─────────────────────────────────────────┐
│  2. DECR (재고 차감)                     │
│     coupon:stock:{eventId}               │
│     → stock < 0? 재고 부족 (롤백)        │
│     → stock >= 0? 계속 진행              │
└─────────────┬───────────────────────────┘
              │ ✅ Success
              ▼
┌─────────────────────────────────────────┐
│  3. RPUSH (큐 추가)                      │
│     coupon:queue:{eventId}               │
│     → userId를 큐 맨 뒤에 추가           │
└─────────────┬───────────────────────────┘
              │
              ▼
    [즉시 성공 응답 200 OK]
    응답 시간: ~150ms
```

#### 3.3.2 비동기 처리 단계 (배치)

```
[Scheduler - 10초마다 실행]
    │
    ▼
┌─────────────────────────────────────────┐
│  1. Redis SCAN                           │
│     → 활성 큐 자동 발견                  │
└─────────────┬───────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│  2. LPOP (100건 꺼내기)                 │
│     coupon:queue:{eventId}               │
│     → [userId1, userId2, ..., userId1000]│
└─────────────┬───────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│  3. UserCoupon 객체 생성                 │
│     List<UserCoupon> userCoupons         │
└─────────────┬───────────────────────────┘
              │
              ▼
┌─────────────────────────────────────────┐
│  4. Bulk Insert (한 번에 100건)         │
│     userCouponRepository.saveAll()       │
│     → @Transactional 보장                │
└─────────────┬───────────────────────────┘
              │
              ▼
    [큐에서 자동 제거 완료]
```

---

## 4. 기술적 의사결정 과정

### 4.1 고려한 설계 방안들

#### 방안 1: DB + 분산 락 (기존 방식)

**처리 흐름:**
1. DB에서 쿠폰 이벤트 조회 (SELECT)
2. 중복 체크 (SELECT)
3. 재고 확인 및 차감 (UPDATE)
4. UserCoupon 생성 (INSERT)

**장점:**
- 구현 간단
- 트랜잭션 일관성 보장

**단점:**
- ❌ 느린 응답 시간 (1초 이상)
- ❌ 분산 락 대기로 병목
- ❌ DB 커넥션 풀 고갈
- ❌ 동시 처리량 한계 (~100 TPS)

**결론:** 대용량 트래픽 처리 불가

---

#### 방안 2: Redis Lua 스크립트

**처리 방식:**
- 중복 체크 + 재고 차감 + 큐 추가를 원자적 실행
- 단일 Lua 스크립트로 모든 로직 처리

**장점:**
- ✅ 완벽한 원자성 (100% 정확도)
- ✅ 빠른 성능

**단점:**
- ❌ Lua 스크립트 복잡도 증가
- ❌ 디버깅 어려움
- ❌ 유지보수 부담

**결론:** 복잡도 대비 이득이 크지 않음

---

#### 방안 3: ZSET Pending/Completed 이중 구조

**자료구조:**
```
coupon:pending:{eventId}   → 배치 처리 대기
coupon:completed:{eventId} → 배치 처리 완료
```

**장점:**
- ✅ 상태 관리 명확
- ✅ 재처리 쉬움 (Pending에 남아있음)

**단점:**
- ❌ ZSET 2개 관리 복잡
- ❌ Pending → Completed 이동 오버헤드
- ❌ 메모리 2배 사용

**결론:** 과도한 설계

---

#### 방안 4: ZSET + List Queue (최종 선택) ⭐

**자료구조:**
```
coupon:issued:{eventId}  → ZSET (중복 체크 + 영구 기록)
coupon:queue:{eventId}   → List (배치 대기열)
coupon:stock:{eventId}   → String (재고)
```

**장점:**
- ✅ 간단함 (3개 Redis 명령만 사용)
- ✅ 역할 분리 (ZSET: 영구, Queue: 임시)
- ✅ 메모리 효율 (Queue는 처리 후 삭제)
- ✅ 확장성 (SCAN으로 자동 발견)
- ✅ 성능 (원자적 연산으로 락 불필요)

**단점:**
- ⚠️ ZADD와 DECR 사이 약간의 gap
- ⚠️ 99.9% 정확도 (재시도 로직으로 해결)

**결론:** 가장 균형 잡힌 방식

### 4.2 왜 최종 방안을 선택했는가?

#### 4.2.1 복잡도 vs 효과

```
복잡도:  낮음 ─────────────────────────── 높음
         │           │           │
         방안4       방안3       방안2

효과:    충분 ─────────────────────────── 완벽
         │           │           │
         방안4       방안3       방안2
```

**선택 원칙:**
> "충분히 좋은(Good Enough) 솔루션이
> 완벽하지만 복잡한 솔루션보다 낫다"

#### 4.2.2 실무 관점

**비즈니스 요구:**
- 5,000개 쿠폰 발급

**실제 운영:**
- 5,100개 준비 (2% 여유분)
- 99.9% 정확도로도 충분

**완벽한 원자성 vs 간단한 구현:**
→ 간단한 구현 선택

### 4.3 핵심 구현 포인트

#### 4.3.1 CouponRedisRepository 역할
- **재고 초기화**: 이벤트 시작 시 재고 설정
- **쿠폰 발급**: ZADD NX → DECR → RPUSH 순서로 처리
- **발급 여부 확인**: ZSCORE로 O(log N) 조회
- **발급자 수 조회**: ZCARD로 O(1) 조회
- **큐 처리**: LPOP으로 배치 크기만큼 꺼내기

#### 4.3.2 IssueCouponUseCase 역할
- 쿠폰 이벤트 유효성 검증 (기간, 존재 여부)
- Redis 발급 시도
- 실패 원인 판단 (중복 vs 재고 부족)
- 즉시 성공 응답 (DB 저장 전)

#### 4.3.3 CouponBatchScheduler 역할
- 10초마다 자동 실행
- Redis SCAN으로 활성 큐 자동 발견
- LPOP으로 1000건씩 꺼내기
- Bulk Insert로 DB 저장
- 큐 자동 정리

---

## 5. 성능 테스트 및 검증

### 5.1 테스트 환경

```
Hardware:
- CPU: Intel i7 (8 cores)
- RAM: 16GB
- Disk: SSD

Software:
- OS: Windows 11
- Java: OpenJDK 17
- Redis: Docker (redis:7-alpine)
- MySQL: Testcontainers

Test Tool:
- MockMvc + ExecutorService
- Thread Pool: 200
```

### 5.2 기능 테스트

#### 5.2.1 정확성 테스트 (10,000명 → 5,000개)

**테스트 시나리오:**
- 총 요청: 10,000명
- 재고: 5,000개
- Thread Pool: 200

**결과:**
```
===== 정확성 테스트 완료 =====
성공: 5,000명 ✅
재고 부족: 5,000명 ✅
중복 발급: 0명 ✅
기타 에러: 0명 ✅

Redis 검증:
- Queue 크기: 5,000개 ✅
- ZSET 크기: 5,000개 ✅
- 재고: 0 ✅

정확도: 100% (5,000/5,000)
```

#### 5.2.2 중복 발급 방지 테스트

**테스트 시나리오:**
- 동일 사용자가 100번 요청
- 예상: 1번만 성공

**결과:**
```
중복 발급 방지 테스트 완료:
- 요청 횟수: 100회
- 성공: 1회 ✅
- 중복 차단: 99회 ✅
```

### 5.3 성능 테스트

#### 5.3.1 응답 시간 측정

**테스트 조건:**
- 총 요청: 10,000건
- 재고: 10,000개

**결과:**
```
===== 응답 시간 통계 =====
평균: 148ms
P50: 132ms ✅
P95: 187ms ✅ (목표 200ms 이내)
P99: 243ms
최대: 412ms
```

#### 5.3.2 처리량(TPS) 측정

**테스트 조건:**
- 총 요청: 10,000건
- Thread Pool: 300

**결과:**
```
총 요청: 10,000건
소요 시간: 4.8초
처리량: 2,083 TPS ✅ (목표 2,000 TPS 달성)
```

### 5.4 극한 테스트

#### 5.4.1 초대형 트래픽 (20,000명 → 5,000개)

**테스트 조건:**
- 총 요청: 20,000명
- 재고: 5,000개
- Thread Pool: 500

**결과:**
```
✅ 성공: 5,000명 (25%)
✅ 재고 부족: 15,000명 (75%)
✅ 소요 시간: 23초
✅ TPS: ~870

결론: 극한 상황에서도 정확도 100% 유지
```

## 결론

### 성과 요약

| 항목 | 결과 |
|------|------|
| **정확도** | 100% (5,000/5,000) |
| **응답 시간** | P95 187ms (목표 200ms 달성) |
| **처리량** | 2,083 TPS (목표 2,000 TPS 달성) |
| **중복 발급** | 0건 |
| **시스템 복잡도** | Low (3개 Redis 자료구조) |

### 최종 평가

**핵심 인사이트:**
1. Redis 자료구조를 조합하여 복잡한 요구사항 해결
2. 완벽한 원자성보다 실용적인 정확도 선택
3. 철저한 테스트로 문제 조기 발견 및 해결
4. 역할 분리로 유지보수성 확보
